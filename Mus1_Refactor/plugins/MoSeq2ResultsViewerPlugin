# Mus1_Refactor/plugins/MoSeq2ResultsViewerPlugin.py

import os
import logging
import h5py
from .base_plugin import BasePlugin

logger = logging.getLogger(__name__)

class MoSeq2ResultsViewerPlugin(BasePlugin):
    """
    Plugin to load and extract key information from existing MoSeq2 result files.
    This plugin DOES NOT RUN MoSeq2; it only reads its output.
    """

    plugin_name = "MoSeq2 Results Viewer"
    plugin_short_description = "Loads summaries from existing MoSeq2 results.h5 files."
    plugin_version = "0.1.0"
    plugin_author = "MUS1 Team"
    plugin_license = "MIT" # Or your preferred license

    # --- Plugin Definition ---

    required_fields = {
        "moseq2_results_file_path": {
            "type": "file",
            "label": "MoSeq2 results.h5 File",
            "tooltip": "Select the main results.h5 file generated by the external MoSeq2 run."
        }
    }

    optional_fields = {
        # Add optional fields if needed, e.g., path to the model file or config
        # "moseq2_model_file_path": {
        #     "type": "file",
        #     "label": "MoSeq2 model.p File (Optional)",
        #     "tooltip": "Optional: Select the corresponding model.p file."
        # }
    }

    analysis_capabilities = [
        {
            "name": "load_moseq2_summary",
            "label": "Load MoSeq2 Summary",
            "description": "Reads the results.h5 file and extracts key summary data (e.g., syllable sequence)."
        }
    ]

    # --- BasePlugin Implementation ---

    def __init__(self):
        super().__init__()
        # Any specific initialization if needed

    def get_required_fields(self):
        return self.required_fields

    def get_optional_fields(self):
        return self.optional_fields

    def get_analysis_capabilities(self):
        return self.analysis_capabilities

    def validate_experiment(self, experiment_metadata, capability_name):
        """Validates prerequisites before running a capability."""
        logger.info(f"Validating experiment {experiment_metadata.experiment_id} for capability {capability_name}")
        params = experiment_metadata.plugin_params.get(self.plugin_name, {})

        if capability_name == "load_moseq2_summary":
            results_path = params.get("moseq2_results_file_path")
            if not results_path:
                raise ValueError(f"Missing required parameter: 'moseq2_results_file_path'")
            if not os.path.exists(results_path):
                raise ValueError(f"MoSeq2 results file not found at: {results_path}")
            # Optional: Add a check to see if it's a valid HDF5 file
            try:
                with h5py.File(results_path, 'r') as f:
                    # Check for a key expected in MoSeq2 results
                    if 'z' not in f:
                         logger.warning(f"File {results_path} might not be a standard MoSeq2 results file (missing 'z').")
            except Exception as e:
                raise ValueError(f"Could not open or read HDF5 file {results_path}: {e}")

        logger.info(f"Validation successful for {capability_name}")
        return True

    def analyze_experiment(self, experiment_metadata, capability_name, data_manager):
        """Executes the 'load_moseq2_summary' capability."""
        logger.info(f"Running capability '{capability_name}' for experiment {experiment_metadata.experiment_id}")
        params = experiment_metadata.plugin_params.get(self.plugin_name, {})
        # analysis_results structure will be populated by ProjectManager based on return value

        if capability_name == "load_moseq2_summary":
            results_path = params.get("moseq2_results_file_path")
            extracted_data = {}

            try:
                with h5py.File(results_path, 'r') as f:
                    # --- Extract Key Information ---
                    # Decide what's most important to have directly in MUS1's analysis_results
                    # Example: Syllable sequence (z)
                    if 'z' in f:
                        # Convert to list for JSON compatibility if storing directly
                        extracted_data['syllable_sequence'] = f['z'][()].tolist()
                        logger.info(f"Extracted syllable sequence (length {len(extracted_data['syllable_sequence'])})")

                    # Example: Number of states (kappa)
                    if 'params/kappa' in f:
                         # Ensure it's a standard Python int
                        extracted_data['kappa'] = int(f['params/kappa'][()])
                        logger.info(f"Extracted kappa: {extracted_data['kappa']}")

                    # Example: Held-out log-likelihood (might be large, consider if needed)
                    # if 'loglikelihoods/heldout_loglikelihoods' in f:
                    #    extracted_data['heldout_loglikelihood'] = f['loglikelihoods/heldout_loglikelihoods'][()].tolist() # Could be big!

                    # You might add more extractions here based on your needs
                    # e.g., dimensions, specific model parameters etc.

                    # Store the path itself for reference
                    extracted_data['source_results_file'] = results_path

            except Exception as e:
                logger.error(f"Error reading MoSeq2 results file {results_path}: {e}", exc_info=True)
                raise # Re-raise to signal failure to ProjectManager

            # Update processing stage - ProjectManager will handle this based on successful execution
            # experiment_metadata.processing_stage = "moseq2_imported" # Or similar

            logger.info(f"Successfully extracted summary from {results_path}")
            # Return the dictionary of extracted data. ProjectManager will store this.
            return extracted_data

        else:
            raise ValueError(f"Unknown capability for {self.plugin_name}: {capability_name}")
