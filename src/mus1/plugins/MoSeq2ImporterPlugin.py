import os
import logging
from pathlib import Path
from datetime import datetime
from typing import Dict, Any

import h5py

from .base_plugin import BasePlugin
from ..core.metadata import PluginMetadata

logger = logging.getLogger(__name__)


class MoSeq2ImporterPlugin(BasePlugin):
    """
    MoSeq2 Importer plugin

    - Reads summaries from existing MoSeq2 results.h5 (viewer utility)
    - Imports/moves MoSeq .mkv recordings into a project's flat master library,
      preserving the basename and appending date/hash by default.
    """

    plugin_name = "MoSeq2 Importer"
    plugin_short_description = "Import MoSeq .mkv to master library; can also view results.h5 summaries."
    plugin_version = "0.1.0"
    plugin_author = "MUS1 Team"
    plugin_license = "MIT"

    # --- Viewer (optional) ---
    required_fields = {
        "moseq2_results_file_path": {
            "type": "file",
            "label": "MoSeq2 results.h5 File",
            "tooltip": "Select the main results.h5 file generated by MoSeq2."
        }
    }

    optional_fields = {}

    analysis_capabilities = [
        {
            "name": "load_moseq2_summary",
            "label": "Load MoSeq2 Summary",
            "description": "Reads the results.h5 file and extracts key summary data (e.g., syllable sequence)."
        }
    ]

    def __init__(self) -> None:
        super().__init__()

    def plugin_self_metadata(self) -> PluginMetadata:
        return PluginMetadata(
            name=self.plugin_name,
            date_created=datetime.now(),
            version=self.plugin_version,
            description=self.plugin_short_description,
            author=self.plugin_author,
            supported_experiment_types=[],
            readable_data_formats=[],
            analysis_capabilities=[cap["name"] for cap in self.analysis_capabilities],
            plugin_type="importer",
        )

    def analysis_capabilities(self):
        # Return identifiers only (BasePlugin expects a list[str])
        return [cap["name"] for cap in self.analysis_capabilities]

    def readable_data_formats(self):
        return []

    def get_required_fields(self):
        return self.required_fields

    def get_optional_fields(self):
        return self.optional_fields

    def get_analysis_capabilities(self):
        return self.analysis_capabilities

    # --- Viewer capability ---
    def validate_experiment(self, experiment_metadata, capability_name):
        logger.info(f"Validating experiment {experiment_metadata.experiment_id} for capability {capability_name}")
        params = experiment_metadata.plugin_params.get(self.plugin_name, {})

        if capability_name == "load_moseq2_summary":
            results_path = params.get("moseq2_results_file_path")
            if not results_path:
                raise ValueError("Missing required parameter: 'moseq2_results_file_path'")
            if not os.path.exists(results_path):
                raise ValueError(f"MoSeq2 results file not found at: {results_path}")
            try:
                with h5py.File(results_path, 'r') as f:
                    if 'z' not in f:
                        logger.warning(f"File {results_path} might not be a standard MoSeq2 results file (missing 'z').")
            except Exception as e:
                raise ValueError(f"Could not open or read HDF5 file {results_path}: {e}")

        logger.info(f"Validation successful for {capability_name}")
        return True

    def analyze_experiment(self, experiment_metadata, capability_name, data_manager):
        logger.info(f"Running capability '{capability_name}' for experiment {experiment_metadata.experiment_id}")
        params = experiment_metadata.plugin_params.get(self.plugin_name, {})

        if capability_name == "load_moseq2_summary":
            results_path = params.get("moseq2_results_file_path")
            extracted_data: Dict[str, Any] = {}
            try:
                with h5py.File(results_path, 'r') as f:
                    if 'z' in f:
                        extracted_data['syllable_sequence'] = f['z'][()].tolist()
                        logger.info(f"Extracted syllable sequence (length {len(extracted_data['syllable_sequence'])})")
                    if 'params/kappa' in f:
                        extracted_data['kappa'] = int(f['params/kappa'][()])
                        logger.info(f"Extracted kappa: {extracted_data['kappa']}")
                    extracted_data['source_results_file'] = results_path
            except Exception as e:
                logger.error(f"Error reading MoSeq2 results file {results_path}: {e}", exc_info=True)
                raise
            logger.info(f"Successfully extracted summary from {results_path}")
            return extracted_data

        raise ValueError(f"Unknown capability for {self.plugin_name}: {capability_name}")

    # --- Project-level helper (used by app/GUI) ---
    def import_moseq_mkv(self, *, project_manager, data_manager, moseq_root: Path, dest_base: Path, require_proc: bool = True, dry_run: bool = False) -> Dict[str, Any]:
        """
        Discover MoSeq session .mkv files under moseq_root and stage them into dest_base,
        preserving basename and appending date/hash by default.
        """
        from datetime import datetime as _dt

        mr = Path(moseq_root).expanduser().resolve()
        if not mr.exists():
            return {"status": "failed", "error": f"MoSeq root not found: {mr}"}

        mkv_paths = []
        for p in mr.glob("**/*.mkv"):
            if p.is_file():
                if require_proc:
                    proc = p.parent / "proc" / "results_00.mp4"
                    if not proc.exists():
                        continue
                mkv_paths.append(p)

        if not mkv_paths:
            return {"status": "success", "moved": 0, "message": "No matching MoSeq .mkv files found"}

        if dry_run:
            return {"status": "success", "planned": len(mkv_paths), "destination": str(dest_base)}

        def _namer(src_path: Path) -> str:
            base = src_path.stem
            ext = src_path.suffix
            try:
                h = data_manager.compute_sample_hash(src_path)
                hash8 = h[:8]
            except Exception:
                hash8 = ""
            try:
                st = data_manager._extract_start_time(src_path)
            except Exception:
                st = _dt.fromtimestamp(src_path.stat().st_mtime)
            try:
                name = pattern.format(base=base, ext=ext, date=st, hash8=hash8, subject="", experiment="")
            except Exception:
                name = f"{base}_{hash8}{ext}" if hash8 else f"{base}{ext}"
            if not name.endswith(ext):
                name = f"{name}{ext}"
            return Path(name).name

        # Move (delete source on success)
        src_move = []
        for p in mkv_paths:
            try:
                src_move.append((p, data_manager.compute_sample_hash(p)))
            except Exception:
                continue

        gen_move = data_manager.stage_files_to_shared(
            src_move,
            shared_root=dest_base.parent.parent,
            dest_base=dest_base,
            overwrite=False,
            progress_cb=None,
            delete_source_on_success=True,
            namer=_namer,
        )
        added = project_manager.register_unlinked_videos(gen_move)
        return {"status": "success", "moved": added, "destination": str(dest_base)}

    # Standard project-level entrypoint so app/CLI can call via ProjectManager.run_project_level_plugin_action
    def run_import(self, params: Dict[str, Any], project_manager) -> Dict[str, Any]:
        try:
            # Ensure a project is loaded
            if not getattr(project_manager, "_current_project_root", None):
                proj = params.get("project_path")
                if proj:
                    project_manager.load_project(Path(proj))
                else:
                    raise RuntimeError("Project not loaded and project_path not provided")

            ps = project_manager.state_manager.project_state
            sr = ps.shared_root or project_manager.get_shared_directory()
            shared_root = Path(sr).expanduser().resolve()
            dest_subdir = params.get("dest_subdir", "recordings/master")
            dest_base = (shared_root / dest_subdir).expanduser().resolve()
            moseq_root = Path(params["moseq_root"]).expanduser().resolve()
            pattern = params.get("pattern", "{base}_{date:%Y%m%d}_{hash8}{ext}")
            require_proc = bool(params.get("require_proc", True))
            dry_run = bool(params.get("dry_run", False))

            return self.import_moseq_mkv(
                project_manager=project_manager,
                data_manager=project_manager.data_manager,
                moseq_root=moseq_root,
                dest_base=dest_base,
                pattern=pattern,
                require_proc=require_proc,
                dry_run=dry_run,
            )
        except Exception as e:
            logger.error(f"MoSeq2ImporterPlugin.run_import failed: {e}", exc_info=True)
            return {"status": "failed", "error": str(e)}


